# Factories

In FluentFixture, factories are the smallest unit of the data generators. From the constant numbers to a massive amount of complex data, it's all generated by a collection of factories. The core design of the FluentFixture rely on the following four principles:

* Everything is immutable. The behavior of a factory cannot be modified after the instance was created.
* The only way to introduce new behaviors is to decorate factories with another factory.
* The only way to use static data with the FluentFixture is using adapters. Fortunately, the FluentFixture brings lots of built-in adapters.
* Factories check the types and values of the given parameters during the initialization step.

## Everything is immutable

A factory is the smallest unit of data generators. By design, all factories are immutable. By this approach, a factory always generates a predictable output. In this way, reusing predefined factories are side-effect-free. There is no way to modify the parameters of the factory below.

```typescript
// example
```

## Introducing new behaviors

A factory alone is not enough to generate complex data. To achieve that, factories can decorate other factories. More on decorators can be found in the [Decorators](broken-reference) section.

```typescript
// example
```

## Adapting static data

In FluentFixture, even constant values are generated by factories in the FluentFixture. This approach is expensive but required to satisfy immutability and fluent interface. More on adapters can be found in the [Adapters](broken-reference) section.

```typescript
// example
```

## Fail-fast

Factories check the types and values of the given parameters during the initialization step. This parameter check is very critical for consistency and troubleshooting; if checks are failed, factories throw human-readable errors.

```typescript
// example
```

## Conclusion

Factories are capable and straightforward, but it is hard to create complex mock data. First of all, too many manual initializations are needed, making code unreadable. For this reason, they are wrapped by another type, [streams](broken-reference).

## Deep dive in factories

{% content-ref url="broken-reference" %}
[Broken link](broken-reference)
{% endcontent-ref %}

{% content-ref url="broken-reference" %}
[Broken link](broken-reference)
{% endcontent-ref %}

{% content-ref url="broken-reference" %}
[Broken link](broken-reference)
{% endcontent-ref %}
