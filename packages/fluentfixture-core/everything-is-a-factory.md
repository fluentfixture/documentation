---
cover: >-
  https://images.unsplash.com/photo-1516937941344-00b4e0337589?crop=entropy&cs=tinysrgb&fm=jpg&ixid=MnwxOTcwMjR8MHwxfHNlYXJjaHwyfHxmYWN0b3J5fGVufDB8fHx8MTY2MjEyMjE0Ng&ixlib=rb-1.2.1&q=80
coverY: 0
---

# üè≠ Everything Is A Factory

In [@fluentfixture](../../), factories are the smallest unit of the data generators. From simple numbers to a massive amount of complex data, it's all generated by a collection of factories. The core design of the library relies on the following three principles:

* Immutability
* Reusability&#x20;
* Fail-fast

### Immutability

Everything is immutable. The behavior of a factory cannot be modified after the instance was created. The only way to introduce new behaviors is to decorate factories with other factories. This behavior is crucial for reusability and eliminating side effects.

```typescript
import { int } from '@fluentfixture/core';

const integer = int(0, 100);

console.log(integer.many(100));
```

In the example above, there is no way to change the lower bound and the upper bound of the integer variable.

### Reusability

Because of the [immutability](everything-is-a-factory.md#immutability) approach, all factories are reusable.

```typescript
import { int } from '@fluentfixture/core';

const integer = int(0, 100);

const integerPlusHalf1 = int(1, 100).add(0.5);
const integerPlusHalf2 = integer.add(0.5);
```

In the example above, `integerPlusHalf1` and `integerPlusHalf2` are identical. Without immutability, we cannot predict the output because every modification on the `integer` variable affects the output.

### Fail-fast

Factories check the types and values of the given parameters during the initialization step.

```typescript
import { int } from '@fluentfixture/core';

const integer = int('0', 100);

console.log(integer.many(100));
```

In the example above, a parameter exception occurs during the initialization. Therefore, the last line will never be executed.
